// Multi-file reader generated by CodeGeeX, with prompts as follows:
//
// 1. 在 c++ 中，请写一个多文件阅读器，我将用 std::vector<std::string> 以及它在文件的每个开头应该忽略多少字节来初始化它，
//    然后每次我给它一个指针和要读取的字节数(可能大于或小于单个文件)，它应该将这样的数据量连续地读到该指针中，
//    就好像这些文件是单个巨大的文件一样 (除了被忽略的字节). 注意请不要一次将文件全都读入内存，因为总文件大小远大于内存容量; 
//    文件较多, 请每次只打开一个文件
// 
// 2. 请一次只使用一个 std::ifstream, 即不要使用 std::vector<std::ifstream>, 否则可能造成资源耗尽
// 
// 3. 如果不使用缓冲区，能否实现?
// 
// 4. 可以在打开文件时就把需要忽略的字节跳过
// 
// 5. file_size 的读取方式不正确，但是你可以用 c++17 的 filesystem 来解决这个问题; 并且在第一次调用 read() 时没有文件打开, 
//    这会使得 read() 总是无法读到数据
// 
// 6. 目前的代码似乎仍然无法使得构造之后调用 read() 时能读到数据，是否有必要在构造函数中调用 openNextFile()?
// 
// 7. 还有一个小错误, std::filesystem::file_size_t 并不存在

// modification:
// 
// 1. in-class std::vector -> std::deque, for performance
// 2. debug log added

// clang-format off

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <filesystem>
#include <deque>

#include "srtb/log/log.hpp"

class MultiFileReader {
private:
    std::deque<std::string> filenames;
    std::ifstream file;
    std::streamsize bytes_to_ignore;
    std::size_t file_size;

public:
    MultiFileReader(const std::vector<std::string>& filenames_, std::streamsize bytes_to_ignore_)
        : bytes_to_ignore(bytes_to_ignore_) {
            for (auto&& s: filenames_){
                filenames.push_back(s);
            }
        }

    ~MultiFileReader() {
        if (file.is_open()) {
            file.close();
        }
    }

    // 从当前文件读取数据到ptr指向的位置，返回实际读取的字节数
    std::streamsize read(char* ptr, std::streamsize n) {
        if (!file.is_open()) {
            openNextFile();
        }

        std::streamsize bytes_read = 0;
        while (n > 0) {
            std::streamsize bytes_to_read = std::min(n, static_cast<std::streamsize>(file_size - file.tellg()));
            file.read(ptr, bytes_to_read);
            std::streamsize bytes_actually_read = file.gcount();

            if (bytes_actually_read == 0) {
                // 当前文件已经读取完毕，关闭文件并打开下一个文件
                file.close();
                if (filenames.empty()) {
                    break;
                }
                openNextFile();
                continue;
            }

            ptr += bytes_actually_read;
            bytes_read += bytes_actually_read;
            n -= bytes_actually_read;
        }
        return bytes_read;
    }

    // 打开下一个文件并准备读取
    void openNextFile() {
        if (filenames.empty()) {
            return; // 没有更多的文件可以打开
        }

        std::string filename = filenames.front();
        filenames.pop_front();

        SRTB_LOGD << " [MultiFileReader] " << "打开文件 " << filename << srtb::endl;
        file.open(filename, std::ios::binary);
        if (!file.is_open()) {
            throw std::runtime_error("无法打开文件: " + filename);
        }
        
        file.seekg(bytes_to_ignore, std::ios::beg);
        file_size = std::filesystem::file_size(filename);
        file.seekg(0, std::ios::cur);
    }
};

// clang-format on
